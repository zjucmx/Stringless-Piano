C51 COMPILER V9.57.0.0   DISPLAY                                                           08/22/2020 13:59:42 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE DISPLAY
OBJECT MODULE PLACED IN .\Objects\display.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE ..\源文件\display.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\display.lst) TABS(2) OBJECT(.\Objects\display.obj)

line level    source

   1          #include "sys_cfg.h"
   2          #include "display.h"
   3          
   4          
   5          /***********LCD12864液晶测忙子程序(读状态)************/ 
   6          void Busy()   
   7          {   
   8   1        uchar busy;
   9   1        do  
  10   1        {      
  11   2          E = 0;      //0为关闭使能端,1为打开使能端      
  12   2          DI = 0;      //1为指令,0为数据      
  13   2          RW = 1;    //1为读,0为写       
  14   2          Delay_1ms(20);  //延时20乘以120时间      
  15   2          E = 1;     //0为关闭使能端,1为打开使能端  
  16   2          P2M0=0x00;
  17   2          P2M1=0x00;  //将P2设为准双向（传统51IO口）  
  18   2          busy=P2;    //读取P2状态      
  19   2          Delay_1ms(20);  //延时20乘以120时间      
  20   2          E = 0;    //0为关闭使能端,1为打开使能端     
  21   2        }while(busy&0x80);  //判断BUSY位是否工作:1为内部在工作,0为正常状态 
  22   1      }  
  23          /*********************************************   LCD12864液晶数据写入子程序  *****************************
             -****************/ 
  24          void Write_Data(uchar k) 
  25          {   
  26   1        Busy();   //测忙
  27   1        E =1;   //0为关闭使能端,1为打开使能端    
  28   1        DI=1;   //1为指令,0为数据    
  29   1        RW=0;   //1为读,0为写   
  30   1        P2M0=0xFF;
  31   1        P2M1=0x00;  //将P2设为推挽    
  32   1        P2=k;   //输入数据K到DATA    
  33   1        Delay_1ms(20); //延时20乘以120时间    
  34   1        E =0;    //0为关闭使能端,1为打开使能端    
  35   1        Delay_1ms(20);   //延时20乘以120时间 
  36   1      }  
  37          
  38          /*********************************************   LCD12864液晶命令写入子程序  *****************************
             -****************/ 
  39          void Write_Cmd(uchar cmd) 
  40          {      
  41   1        Busy();    //测忙
  42   1        E=1;   //0为关闭使能端,1为打开使能端     
  43   1        DI=0;    //1为指令,0为数据     
  44   1        RW=0;   //1为读,0为写   
  45   1        P2M0=0xFF;
  46   1        P2M1=0x00;  //将P2设为推挽 
  47   1        P2=cmd;    //输入命令cmd到DATA     
  48   1        Delay_1ms(20); //延时20乘以120时间 
  49   1        E=0;   //0为关闭使能端,1为打开使能端     
  50   1        Delay_1ms(20); //延时20乘以120时间 
  51   1      }  
  52          
C51 COMPILER V9.57.0.0   DISPLAY                                                           08/22/2020 13:59:42 PAGE 2   

  53          
  54          //显示数组字符串(显示半宽字型16*8点阵)
  55          void ShowQQChar(uchar addr,uchar *english,uchar count)//DDRAM地址，数据首字节指针，数据长度
  56          {
  57   1        uchar i;
  58   1        Write_Cmd(addr); //设定DDRAM地址
  59   1        for(i=0;i<count;)
  60   1        {
  61   2          Write_Data(english[i*2]);
  62   2          Write_Data(english[i*2+1]);
  63   2          i++;
  64   2        }
  65   1      }
  66          
  67          //字符和汉字显示
  68          /*********************************************   LCD12864液晶数据显示子程序  *****************************
             -****************/ 
  69          void Disp(uchar y,uchar x,uchar i,uchar *z)   
  70          {     
  71   1        uchar Address;    
  72   1        //Y判断第几行,X判断第几列,0x80为液晶行初始地址    
  73   1        if(y==1)  Address=0x80+x;
  74   1        if(y==2){Address=0x90+x;}        
  75   1        if(y==3){Address=0x88+x;}    
  76   1        if(y==4){Address=0x98+x;}  
  77   1        Write_Cmd(Address);//写入地址命令到LCD12864  
  78   1        while(i)       //写入显示数据的大小  
  79   1        {    
  80   2          Write_Data(*(z++));    //写入显示数据到LCD12864    
  81   2          i--;         
  82   2        }   
  83   1      } 
  84            
  85          //自定义字符1（16X16）写入CGRAM //
  86          void WRCGRAM1(uchar addr)//单下划线
  87          {
  88   1        uchar i;
  89   1        for(i=0;i<2;)
  90   1        {
  91   2          Write_Cmd(addr+i); //设定CGRAM地址
  92   2          Write_Data(0xff);
  93   2          Write_Data(0x00);
  94   2          i++;
  95   2          Write_Cmd(addr+i); //设定CGRAM地址
  96   2          Write_Data(0x00);
  97   2          Write_Data(0x00);
  98   2          i++;
  99   2        }
 100   1        for(i=2;i<16;i++)
 101   1        {
 102   2          Write_Cmd(addr+i); //设定CGRAM地址
 103   2          Write_Data(0x00);
 104   2          Write_Data(0x00);
 105   2        }
 106   1      }
 107          
 108          //自定义字符2（16X16）写入CGRAM //
 109          void WRCGRAM2(uchar addr)//双下划线
 110          {
 111   1        uchar i;
 112   1        for(i=0;i<4;)
 113   1        {
C51 COMPILER V9.57.0.0   DISPLAY                                                           08/22/2020 13:59:42 PAGE 3   

 114   2          Write_Cmd(addr+i); //设定CGRAM地址
 115   2          Write_Data(0xff);
 116   2          Write_Data(0x00);
 117   2          i++;
 118   2          Write_Cmd(addr+i); //设定CGRAM地址
 119   2          Write_Data(0x00);
 120   2          Write_Data(0x00);
 121   2          i++;
 122   2        }
 123   1        for(i=4;i<16;i++)
 124   1        {
 125   2          Write_Cmd(addr+i); //设定CGRAM地址
 126   2          Write_Data(0x00);
 127   2          Write_Data(0x00);
 128   2        }
 129   1      }
 130          
 131          //自定义字符3（16X16）写入CGRAM //
 132          void WRCGRAM3(uchar addr)//单下划线加点
 133          {
 134   1        uchar i;
 135   1        for(i=0;i<2;)
 136   1        {
 137   2          Write_Cmd(addr+i); //设定CGRAM地址
 138   2          Write_Data(0xff);
 139   2          Write_Data(0x00);
 140   2          i++;
 141   2          Write_Cmd(addr+i); //设定CGRAM地址
 142   2          Write_Data(0x00);
 143   2          Write_Data(0x00);
 144   2          i++;
 145   2        }
 146   1        for(i=2;i<6;)
 147   1        {
 148   2          Write_Cmd(addr+i); //设定CGRAM地址
 149   2          Write_Data(0x00);
 150   2          Write_Data(0x00);
 151   2          i++;
 152   2        }
 153   1        Write_Cmd(addr+6);Write_Data(0x18);Write_Data(0x00);
 154   1        Write_Cmd(addr+7);Write_Data(0x3c);Write_Data(0x00);
 155   1        Write_Cmd(addr+8);Write_Data(0x3c);Write_Data(0x00);
 156   1        Write_Cmd(addr+9);Write_Data(0x18);Write_Data(0x00);
 157   1        for(i=10;i<16;i++)
 158   1        {
 159   2          Write_Cmd(addr+i); //设定CGRAM地址
 160   2          Write_Data(0x00);
 161   2          Write_Data(0x00);
 162   2        }
 163   1      }
 164          
 165          //自定义字符4（16X16）写入CGRAM //
 166          void WRCGRAM4(uchar addr)//双下划线加点
 167          {
 168   1        uchar i;
 169   1        for(i=0;i<4;)
 170   1        {
 171   2          Write_Cmd(addr+i); //设定CGRAM地址
 172   2          Write_Data(0xff);
 173   2          Write_Data(0x00);
 174   2          i++;
 175   2          Write_Cmd(addr+i); //设定CGRAM地址
C51 COMPILER V9.57.0.0   DISPLAY                                                           08/22/2020 13:59:42 PAGE 4   

 176   2          Write_Data(0x00);
 177   2          Write_Data(0x00);
 178   2          i++;
 179   2        }
 180   1        Write_Cmd(addr+4);Write_Data(0x00);Write_Data(0x00);
 181   1        Write_Cmd(addr+5);Write_Data(0x00);Write_Data(0x00);
 182   1        Write_Cmd(addr+6);Write_Data(0x18);Write_Data(0x00);
 183   1        Write_Cmd(addr+7);Write_Data(0x3c);Write_Data(0x00);
 184   1        Write_Cmd(addr+8);Write_Data(0x3c);Write_Data(0x00);
 185   1        Write_Cmd(addr+9);Write_Data(0x18);Write_Data(0x00);
 186   1        for(i=10;i<16;i++)
 187   1        {
 188   2          Write_Cmd(addr+i); //设定CGRAM地址
 189   2          Write_Data(0x00);
 190   2          Write_Data(0x00);
 191   2        }
 192   1      }
 193          
 194          void CLEARGDRAM(void)//绘图清屏  
 195          {
 196   1        uchar j;
 197   1        uchar i;
 198   1        Write_Cmd(0x34);  //切换扩充指令集
 199   1        Write_Cmd(0x36);  //绘图显示开
 200   1        for(j=0;j<32;j++)
 201   1        {
 202   2          Write_Cmd(0x80+j);//y坐标 共32行
 203   2          Write_Cmd(0x80);//X坐标
 204   2          for(i=0;i<32;i++)//
 205   2          {
 206   3            Write_Data(0x00);//绘空格32*8个即256空格
 207   3          }
 208   2        }
 209   1      }
 210          
 211          //写入GDRAM 绘图,Y是Y绘图坐标,2个字节一行,CLONG是图形长度,以字节
 212          //为单位;HIGHT是图形高度,TAB是图形数据表.12864M的图形显示是相当于256*32.
 213          //由两屏128*32上下两屏组成，同一行的下屏的头地址紧接上屏的未地址。
 214          //绘图在串口输入时,会比在并口下的输入要慢一些
 215          void WRGDRAM(uchar Y1,uchar clong,uchar hight,uchar *TAB1)
 216          {
 217   1        uint k;
 218   1        uchar j;
 219   1        uchar i;
 220   1        Write_Cmd(0x34);
 221   1        Write_Cmd(0x36);
 222   1        for(j=0;j<hight;j++)//32
 223   1        { //先上半屏
 224   2          Write_Cmd(Y1+j); //Y总坐标,即第几行
 225   2          Write_Cmd(0x80);//X坐标0，即横数第0个字节开始写起   
 226   2          for(i=0;i<clong;i++)//
 227   2          {
 228   3            Write_Data(TAB1[clong*j+i]);
 229   3          }
 230   2        //后下半屏
 231   2          for(k=0;k<clong;k++)//
 232   2          {
 233   3            Write_Data(TAB1[clong*(j+hight)+k]);
 234   3          }
 235   2        }
 236   1        Write_Cmd(0x30);
 237   1      }
C51 COMPILER V9.57.0.0   DISPLAY                                                           08/22/2020 13:59:42 PAGE 5   

 238          
 239          void Cursor(uchar x,uchar y)
 240          {
 241   1        Write_Cmd(0x34);
 242   1        Write_Cmd(y);
 243   1        Write_Cmd(x);
 244   1      }
 245          
 246          void DISPIcon(uchar x,uchar y,uchar clong,uchar hight,uchar *Icon)//插入图标
 247          {
 248   1        uchar i,j;
 249   1        for(i=0;i<hight;i++)
 250   1        {
 251   2          if(y+i<32)
 252   2            Cursor(0x80+x/16,0x80+y+i);//上半屏设定起始位置
 253   2          else
 254   2            Cursor(0x88+x/16,0x80-32+y+i);//下半屏设定起始位置
 255   2          for(j=0;j<clong;j++)
 256   2            Write_Data(Icon[clong*i+j]);
 257   2        }
 258   1        Write_Cmd(0x36);
 259   1        Write_Cmd(0x30);
 260   1      } 
 261          
 262          
 263           /*********************************************   LCD12864液晶初始化子程序  ******************************
             -***************/ 
 264           void Ini_Lcd(void)     
 265           {     
 266   1      
 267   1         PSB=1;     
 268   1         Delay_1ms(20);                  
 269   1         Write_Cmd(0x30);   //基本指令集     
 270   1         Delay_1ms(20);      
 271   1         Write_Cmd(0x02);   // 地址归位     
 272   1         Delay_1ms(20);      
 273   1         Write_Cmd(0x0c);   //整体显示打开,游标关闭     
 274   1         Delay_1ms(20);      
 275   1         Write_Cmd(0x06);   //游标右移     
 276   1         Delay_1ms(20);      
 277   1         Write_Cmd(0x80);   //设定显示的起始地址     
 278   1         Delay_1ms(20);      
 279   1         Write_Cmd(0x01);   //清除显示 
 280   1       }
 281          
 282          
 283          void antibackgroud(uint hang)//某一行首反白显示
 284          {
 285   1        Write_Cmd(0x80+8*(hang/2)+16*(hang%2));
 286   1        Write_Cmd(0x0F);
 287   1      }
 288          
 289          
 290          /*******************延时子程序  ********************/ 
 291          void Delay_1ms(uint x) 
 292          {  
 293   1        uint j,i;   
 294   1        for(j=0;j<x;j++)   
 295   1        {    
 296   2          for(i=0;i<120;i++);   //延时X乘以120  
 297   2        }  
 298   1      }
C51 COMPILER V9.57.0.0   DISPLAY                                                           08/22/2020 13:59:42 PAGE 6   

 299          
 300          
 301          void delayNus(uchar x)  //LCD串口时指令和数据之间的延时
 302          {
 303   1      uchar k;
 304   1      for(k=0;k<x;k++);
 305   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1231    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      47
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
